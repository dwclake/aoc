/*
 * Advent of Code 2023
 * Day 2
 * Cube Conundrum
 */

use core {*}

path :: "src/day2/inputs.txt"

Subset :: struct {
    blue: i64 = 0;
    green: i64 = 0;
    red: i64 = 0;
}

Game :: struct {
    id: i64 = 0;
    set: [..]Subset;
}

scan :: (line: str) -> Game {
    game := Game.{};
    array.init(&game.set);
    
    // split the game into two sections: game id, set
    info := line 
        |> string.split_iter(':')
        |> iter.collect();

    // parse game id
    game.id = string.split(info[0], ' ')[1]
        |> conv.parse_int();

    // split set into subsets
    set := info[1]
        |> string.split(';');

    // for each subset, parse the count for each colour
    for subset: set {
        blue: i64 = 0;
        green: i64 = 0;
        red: i64 = 0;

        // split the subset into colours
        colours := string.split(subset, ',');

        // for each pair of (count, colour) parse the count and store it 
        // in the corresponding variable
        for pair: colours {
            split := pair
                |> string.trim_start(' ')
                |> string.split(' ');

            count := split[0]
                |> conv.parse_int();

            switch split[1] {
                case "blue" do blue = count;
                case "green" do green = count;
                case "red" do red = count;
            }
        }

        // append subset to game.set
        game.set << Subset.{blue, green, red};
    }

    return game;
}

scan2 :: (line: str) -> i64 {
    power: i64 = 1;
    blue: i64 = 0;
    green: i64 = 0;
    red: i64 = 0;
    
    // split the game into two sections: game id, set
    info := line 
        |> string.split_iter(':')
        |> iter.collect();

    // split set into subsets
    set := info[1]
        |> string.split(';');

    // for each subset, parse the count for each colour
    for subset: set {
        // split the subset into colours
        colours := string.split(subset, ',');

        // for each pair of (count, colour) parse the count and store it 
        // in the corresponding variable
        for pair: colours {
            split := pair
                |> string.trim_start(' ')
                |> string.split(' ');

            count := split[0]
                |> conv.parse_int();

            switch split[1] {
                case "blue" do blue = math.max(blue, count); 
                case "green" do green = math.max(green, count);
                case "red" do red = math.max(red, count);
            }
        }
    }

    power = blue * red * green;

    return power;
}

check :: (game: Game, nblue: i64, ngreen: i64, nred: i64) -> bool {
    for subset: game.set {
        if subset.blue > nblue || subset.green > ngreen || subset.red > nred {
            return false;
        }
    }

    return true;
}

main :: (_: any) -> Result(void, os.FileError) {
    file := os.open(path)?;
    defer os.close(&file);

    contents := os.get_contents(&file);

    nblue :: cast(i64) 14;
    ngreen :: cast(i64) 13;
    nred :: cast(i64) 12;

    games := string.split_iter(contents, '\n')
        |> iter.map(scan);

    defer for game: games {
        array.free(&game.set);
    }
    
    sum := games
        |> iter.filter(game => check(game, nblue, ngreen, nred))
        |> iter.map(game => game.id)
        |> iter.fold(cast(i64) 0, (a, b) => a + b);

    printf("part 1: {}\n", sum);
    
    sum2 := string.split_iter(contents, '\n')
        |> iter.map(scan2)
        |> iter.fold(cast(i64) 0, (a, b) => a + b);
    
    printf("part 2: {}\n", sum2);
}
