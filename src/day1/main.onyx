/*  
 * Advent of Code 2023
 * Day 1
 * Trebuchet?!
 */

use core {*}

path :: "src/day1/inputs.txt"

words :: .[
    "one", "two", "three", "four", "five", 
    "six", "seven", "eight", "nine", "zero"
];

char_of_word :: (word: str) -> ?u8 {
    switch word {
        case "one"   { return '1'; }
        case "two"   { return '2'; }
        case "three" { return '3'; }
        case "four"  { return '4'; }
        case "five"  { return '5'; }
        case "six"   { return '6'; }
        case "seven" { return '7'; }
        case "eight" { return '8'; }
        case "nine"  { return '9'; }
        case "zero"  { return '0'; }
    }
}

scan :: (string: str) -> i32 {
    first: ?u8 = .{};
    final: ?u8 = .{};

    result := array.make(u8, 2);
    defer array.free(&result);

    for i: 0..string.count {
        switch string[i] {
            // char is a digit
            case '0'..'9' {
                if !first { 
                    first = string[i]; 
                } else { 
                    final = string[i]; 
                }
            }
            // char is alphabetical
            // need to check for word of digits ie. one, two, ..., nine
            case 'e'..'z' {
                for word: words {
                    if string[i..i+word.count] == word {
                        if !first { 
                            first = char_of_word(word)?; 
                        } else { 
                            final = char_of_word(word)?; 
                        }

                        break;
                    }
                }
            }
        } 
    }

    result << first?;
    result << final ?? first?;

    return cast(i32) conv.parse_int(result);
}

main :: (args: [][&]u8) -> Result(void, os.FileError) {
    file := os.open(path)?;
    defer os.close(&file);

    contents := os.get_contents(&file);

    sum := string.split_iter(contents, '\n')
        |> iter.map(scan)
        |> iter.fold(0, (a, b) => a + b);

    printf("Sum of calibrations: {}\n", sum);

    return .Ok;
}
